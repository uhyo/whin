// Generated by CoffeeScript 1.6.3
(function() {
  var Compiler, idtm, wo;

  idtm = require('../js/idtm');

  wo = require('./operations');

  Compiler = (function() {
    function Compiler() {
      this.result = [];
      this.myLabelnumber = 0;
      this.labels = [];
      this.heap = [];
    }

    Compiler.prototype.compile = function(ops) {
      var op, _i, _len;
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        this.maincalc(op);
      }
      return this.result;
    };

    Compiler.prototype.maincalc = function(op) {
      var constr, lb, neg, pos, tmplb;
      if (op instanceof idtm.Label) {
        return this.result.push(new wo.flow.Label(this.getLabel(op)));
      } else if (op instanceof idtm.SubstituteOperation) {
        pos = this.allocHeap(op.v);
        this.result.push(new wo.stack.Push(pos));
        this.onstack(op.value);
        if ((op.v.type != null) && op.v.type === op.v.TYPE_STRING) {
          throw new Error("未実装:文字列のコピー");
        } else {
          return this.result.push(new wo.heap.Store);
        }
      } else if (op instanceof idtm.JumpOperation) {
        lb = this.getLabel(op.label);
        return this.result.push(new wo.flow.Jump(lb));
      } else if (op instanceof idtm.JumpifOperation || op instanceof idtm.JumpunlessOperation) {
        constr = null;
        neg = false;
        /*
        if op.cond instanceof idtm.Calc2
            switch op.cond.punc
                when "+","-","*","/","%"
                    @onstack op.cond
                    constr=wo.flow.JumpZero
                    neg=!neg
                when "!=","!=="
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    # 引き算して違えばいい
                    @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpZero
                    neg=!neg
                when "==","==="
                    # 同じならいい
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    # 引き算して違えばいい
                    @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpZero
                when ">",">="
                    # 小から大をひいてみる
                    @onstack op.cond.val2
                    @onstack op.cond.val1
                    @result.push new wo.arithmetic.Subtract
                    if op.cond.punc==">="
                        # 0も許すので1ひく
                        @result.push new wo.stack.Push 1
                        @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpNegative
                when "<","<="
                    # 小から大をひいてみる
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    @result.push new wo.arithmetic.Subtract
                    if op.cond.punc=="<="
                        # 0も許すので1ひく
                        @result.push new wo.stack.Push 1
                        @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpNegative
                when "||","&&"
                    @onstack new idtm.Calc1 "to_boolean",op.cond.val1
                    @onstack new idtm.Calc1 "to_boolean",op.cond.val2
                    if op.cond.punc=="||"
                        # 論理和
                        @result.push new wo.arithmetic.Add
                    else
                        # 論理積
                        @result.push new wo.arithmetic.Multiply
                    neg=!neg
                    constr=wo.flow.JumpZero
        else
            #Calc2以外
            @onstack new idtm.Calc1 "to_boolean",op.cond
            constr=wo.flow.JumpZero
        */

        this.onstack(new idtm.Calc1("to_boolean", op.cond));
        neg = !neg;
        constr = wo.flow.JumpZero;
        if (op instanceof idtm.JumpunlessOperation) {
          neg = !neg;
        }
        if (neg) {
          tmplb = this.getLabel();
          this.result.push(new constr(tmplb));
          this.result.push(new wo.flow.Jump(this.getLabel(op.label)));
          return this.result.push(new wo.flow.Label(tmplb));
        } else {
          return this.result.push(new constr(this.getLabel(op.label)));
        }
      } else if (op instanceof idtm.ReturnOperation) {
        if (op.returnvalue != null) {
          this.onstack(op.returnvalue);
        } else {
          this.result.push(new wo.stack.Push(0));
        }
        return this.result.push(new wo.flow.Return);
      } else if (op instanceof idtm.End) {
        return this.result.push(new wo.flow.End);
      } else if (op instanceof idtm.FunctionStart) {
        lb = this.getLabel(op.func);
        return this.result.push(new wo.flow.Label(lb));
      }
    };

    Compiler.prototype.onstack = function(obj) {
      var a, args, code, endlb, heappos, i, lb, mae, octets, pos, tmpend, tmplb, tmpv, uuuuu, v, _i, _j, _len, _ref, _ref1, _results;
      if (obj instanceof idtm.Variable) {
        pos = this.allocHeap(obj);
        this.result.push(new wo.stack.Push(pos));
        return this.result.push(new wo.heap.Retrieve);
      } else if (obj instanceof idtm.Literal) {
        if (obj.type === obj.TYPE_STRING) {
          this.result.push(new wo.stack.Push(0));
          _results = [];
          for (i = _i = 0, _ref = obj.value.length; _i > _ref; i = _i += -1) {
            code = obj.value.charCodeAt(i);
            octets = code < 0x80 ? [code] : code < 0x800 ? [0xC0 | ((code >>> 6) & 0x1F), 0x80 | (code & 0x3F)] : code < 0xD7FF || (0xE000 <= code && code < 0x10000) ? [0xE0 | ((code >>> 12) & 0x0F), 0x80 | ((code >>> 6) & 0x3F), 0x80 | (code & 0x3F)] : 0xDC00 <= code ? (mae = obj.value.charCodeAt(i - 1), uuuuu = ((mae >>> 6) & 0x0F) + 1, [0xF0 | (uuuuu >> 2), 0x80 | ((uuuuu & 3) << 4) | ((mae >> 2) & 0x0F), 0x80 | ((mae & 3) << 4) | ((code >> 6) & 0x0F), 0x80 | (code & 0x3F)]) : [];
            octets.reverse();
            _results.push((function() {
              var _j, _len, _results1;
              _results1 = [];
              for (_j = 0, _len = octets.length; _j < _len; _j++) {
                code = octets[_j];
                _results1.push(this.result.push(new wo.stack.Push(code)));
              }
              return _results1;
            }).call(this));
          }
          return _results;
        } else {
          return this.result.push(new wo.stack.Push(+obj.value));
        }
      } else if (obj instanceof idtm.Calc) {
        if (obj instanceof idtm.Calc1) {
          switch (obj.op) {
            case "to_number":
              return this.onstack(obj.value);
            case "to_boolean":
            case "!":
              this.onstack(obj.value);
              if (obj.value.type !== obj.value.TYPE_BOOLEAN) {
                tmplb = this.getLabel();
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.flow.JumpZero(tmplb));
                this.result.push(new wo.stack.Discard);
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.flow.Label(tmplb));
              }
              if (obj.op === "!") {
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.stack.Swap);
                return this.result.push(new wo.arithmetic.Subtract);
              }
          }
        } else if (obj instanceof idtm.Calc2) {
          switch (obj.punc) {
            case "+":
            case "-":
            case "*":
            case "/":
            case "%":
              this.onstack(obj.val1);
              this.onstack(obj.val2);
              return this.result.push((function() {
                switch (obj.punc) {
                  case "+":
                    return new wo.arithmetic.Add;
                  case "-":
                    return new wo.arithmetic.Subtract;
                  case "*":
                    return new wo.arithmetic.Multiply;
                  case "/":
                    return new wo.arithmetic.Divide;
                  case "%":
                    return new wo.arithmetic.Modulo;
                }
              })());
            case "!=":
            case "!==":
              return this.onstack(new idtm.Calc1("to_boolean", new idtm.Calc2("-", obj.val1, obj.val2)));
            case "==":
            case "===":
              return this.onstack(new idtm.Calc1("!", new idtm.Calc2("-", obj.val1, obj.val2)));
            case ">":
            case ">=":
            case "<":
            case "<=":
              tmplb = this.getLabel();
              tmpend = this.getLabel();
              switch (obj.punc) {
                case ">":
                case ">=":
                  this.onstack(obj.val2);
                  this.onstack(obj.val1);
                  this.result.push(new wo.arithmetic.Subtract);
                  if (obj.punc === ">=") {
                    this.result.push(new wo.stack.Push(1));
                    this.result.push(new wo.arithmetic.Subtract);
                  }
                  this.result.push(new wo.flow.JumpNegative(tmplb));
                  break;
                case "<":
                case "<=":
                  this.onstack(obj.val1);
                  this.onstack(obj.val2);
                  this.result.push(new wo.arithmetic.Subtract);
                  if (obj.punc === "<=") {
                    this.result.push(new wo.stack.Push(1));
                    this.result.push(new wo.arithmetic.Subtract);
                  }
                  this.result.push(new wo.flow.JumpNegative(tmplb));
              }
              this.result.push(new wo.stack.Push(0));
              this.result.push(new wo.flow.Jump(tmpend));
              this.result.push(new wo.flow.Label(tmplb));
              this.result.push(new wo.stack.Push(1));
              return this.result.push(new wo.flow.Label(tmpend));
            case "||":
              this.onstack(new idtm.Calc1("to_boolean", obj.val1));
              this.onstack(new idtm.Calc1("to_boolean", obj.val2));
              this.result.push(new wo.arithmetic.Add);
              this.result.push(new wo.stack.Duplicate);
              this.resuht.push(new wo.stack.Push(2));
              this.result.push(new wo.arithmetic.Subtract);
              this.result.push(new wo.stack.Push(1));
              tmplb = this.getLabel();
              this.result.push(new wo.flow.JumpZero(tmplb));
              this.result.push(new wo.stack.Discard);
              return this.resutl.push(new wo.stack.Push(0));
            case "&&":
              this.onstack(new idtm.Calc1("to_boolean", obj.val1));
              this.onstack(new idtm.Calc1("to_boolean", obj.val2));
              return this.result.push(new wo.arithmetic.Multiply);
          }
        } else if (obj instanceof idtm.Call) {
          if (obj.func instanceof idtm.NativeFunc) {
            if (obj.func instanceof idtm.Print) {
              a = obj.args[0];
              if (a == null) {
                throw new Error("printの引数がありません。");
              }
              if (a instanceof idtm.Calc2) {
                if ((a.type != null) && a.type === a.TYPE_STRING && a.punc === "+") {
                  this.onstack(new idtm.Call(new idtm.Print, [a.val1]));
                  this.onstack(new idtm.Call(new idtm.Print, [a.val2]));
                  this.result.push(new wo.stack.Discard);
                  return;
                }
              }
              this.onstack(a);
              if ((a.type != null) && a.type === a.TYPE_STRING) {
                tmplb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.flow.Label(tmplb));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.flow.JumpZero(endlb));
                this.result.push(new wo.io.OutputChar);
                this.result.push(new wo.flow.Jump(tmplb));
                return this.result.push(new wo.flow.Label(endlb));
              } else {
                this.result.push(new wo.io.OutputNumber);
                return this.result.push(new wo.stack.Push(0));
              }
            } else if (obj.func instanceof idtm.Charcode) {
              a = obj.args[0];
              if (a == null) {
                throw new Error("charcodeの引数がありません。");
              }
              this.onstack(a);
              if ((a.type != null) && a.type === a.TYPE_STRING) {
                tmpv = new idtm.Variable;
                pos = this.allocHeap(tmpv);
                this.result.push(new wo.stack.Push(pos));
                this.result.push(new wo.stack.Swap);
                this.result.push(new wo.heap.Store);
                tmplb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.flow.Label(tmplb));
                this.result.push(new wo.flow.JumpZero(endlb));
                this.result.push(new wo.flow.Jump(tmplb));
                this.result.push(new wo.flow.Label(endlb));
                this.result.push(new wo.stack.Push(pos));
                return this.result.push(new wo.heap.Retrieve);
              }
            } else if (obj.func instanceof idtm.InputChar) {
              tmpv = new idtm.Variable;
              pos = this.allocHeap(tmpv);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.io.ReadChar);
              this.result.push(new wo.stack.Push(pos));
              return this.result.push(new wo.heap.Retrieve);
            } else if (obj.func instanceof idtm.InputNumber) {
              tmpv = new idtm.Variable;
              pos = this.allocHeap(tmpv);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.io.ReadNumber);
              this.result.push(new wo.stack.Push(pos));
              return this.result.push(new wo.heap.Retrieve);
            } else {
              throw new Error("ん？");
            }
          } else {
            lb = this.getLabel(obj.func);
            args = obj.args;
            _ref1 = obj.func.start.vars;
            for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
              v = _ref1[i];
              if (args[i] == null) {
                throw new Error("引数が足りません");
              }
              heappos = this.allocHeap(v);
              this.result.push(new wo.stack.Push(heappos));
              this.onstack(args[i]);
              this.result.push(new wo.heap.Store);
            }
            return this.result.push(new wo.flow.Call(lb));
          }
        }
      }
    };

    Compiler.prototype.getLabel = function(lb) {
      var thislabel;
      thislabel = this.myLabelnumber;
      if (lb instanceof idtm.Label) {
        if (this.labels[lb.number] != null) {
          return this.labels[lb.number];
        } else {
          this.labels[lb.number] = this.numberToLabelstring(thislabel);
          this.myLabelnumber++;
          return this.labels[lb.number];
        }
      } else if (lb instanceof idtm.Func) {
        if (lb.label != null) {
          return lb.label;
        }
        lb.label = this.numberToLabelstring(thislabel);
        this.myLabelnumber++;
        return lb.label;
      } else {
        this.myLabelnumber++;
        return this.numberToLabelstring(thislabel);
      }
    };

    Compiler.prototype.allocHeap = function(v) {
      var heappos, i, j, len, va, _i, _ref;
      if (v.size == null) {
        if (v.type === v.TYPE_STRING) {
          v.size = 256;
        } else {
          v.size = 1;
        }
      }
      heappos = null;
      i = 0;
      len = this.heap.length;
      while (i < len) {
        va = this.heap[i];
        if (v === va) {
          return i;
        }
        i += va.size;
      }
      while (i < len) {
        va = this.heap[i];
        if (va == null) {
          heappos = i;
          for (j = _i = 1, _ref = v.size; 1 <= _ref ? _i < _ref : _i > _ref; j = 1 <= _ref ? ++_i : --_i) {
            if (this.heap[i + j] != null) {
              heappos = null;
              break;
            }
          }
          if (heappos != null) {
            break;
          }
        }
        i += va.size;
      }
      if (heappos == null) {
        heappos = this.heap.length;
      }
      this.heap[heappos] = v;
      return heappos;
    };

    Compiler.prototype.numberToLabelstring = function(num) {
      var result;
      result = "";
      while (num > 0) {
        if (num % 2 === 1) {
          result = "\t" + result;
          num--;
        } else {
          result = " " + result;
        }
        num /= 2;
      }
      if (result === "") {
        result = " ";
      }
      return result;
    };

    return Compiler;

  })();

  exports.Compiler = Compiler;

}).call(this);
