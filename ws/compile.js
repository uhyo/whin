// Generated by CoffeeScript 1.6.3
(function() {
  var Compiler, idtm, wo;

  idtm = require('../js/idtm');

  wo = require('./operations');

  Compiler = (function() {
    function Compiler() {
      this.result = [];
      this.myLabelnumber = 0;
      this.labels = [];
      this.heap = [];
    }

    Compiler.prototype.compile = function(ops) {
      var op, _i, _len;
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        this.maincalc(op);
      }
      return this.result;
    };

    Compiler.prototype.maincalc = function(op) {
      var constr, lb, neg, tmplb;
      if (op instanceof idtm.Label) {
        return this.result.push(new wo.flow.Label(this.getLabel(op)));
      } else if (op instanceof idtm.SubstituteOperation) {
        return this.calc(op.value, op.v);
      } else if (op instanceof idtm.JumpOperation) {
        lb = this.getLabel(op.label);
        return this.result.push(new wo.flow.Jump(lb));
      } else if (op instanceof idtm.JumpifOperation || op instanceof idtm.JumpunlessOperation) {
        constr = null;
        neg = false;
        /*
        if op.cond instanceof idtm.Calc2
            switch op.cond.punc
                when "+","-","*","/","%"
                    @onstack op.cond
                    constr=wo.flow.JumpZero
                    neg=!neg
                when "!=","!=="
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    # 引き算して違えばいい
                    @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpZero
                    neg=!neg
                when "==","==="
                    # 同じならいい
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    # 引き算して違えばいい
                    @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpZero
                when ">",">="
                    # 小から大をひいてみる
                    @onstack op.cond.val2
                    @onstack op.cond.val1
                    @result.push new wo.arithmetic.Subtract
                    if op.cond.punc==">="
                        # 0も許すので1ひく
                        @result.push new wo.stack.Push 1
                        @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpNegative
                when "<","<="
                    # 小から大をひいてみる
                    @onstack op.cond.val1
                    @onstack op.cond.val2
                    @result.push new wo.arithmetic.Subtract
                    if op.cond.punc=="<="
                        # 0も許すので1ひく
                        @result.push new wo.stack.Push 1
                        @result.push new wo.arithmetic.Subtract
                    constr=wo.flow.JumpNegative
                when "||","&&"
                    @onstack new idtm.Calc1 "to_boolean",op.cond.val1
                    @onstack new idtm.Calc1 "to_boolean",op.cond.val2
                    if op.cond.punc=="||"
                        # 論理和
                        @result.push new wo.arithmetic.Add
                    else
                        # 論理積
                        @result.push new wo.arithmetic.Multiply
                    neg=!neg
                    constr=wo.flow.JumpZero
        else
            #Calc2以外
            @onstack new idtm.Calc1 "to_boolean",op.cond
            constr=wo.flow.JumpZero
        */

        this.onstack(new idtm.Calc1("to_boolean", op.cond));
        neg = !neg;
        constr = wo.flow.JumpZero;
        if (op instanceof idtm.JumpunlessOperation) {
          neg = !neg;
        }
        if (neg) {
          tmplb = this.getLabel();
          this.result.push(new constr(tmplb));
          this.result.push(new wo.flow.Jump(this.getLabel(op.label)));
          return this.result.push(new wo.flow.Label(tmplb));
        } else {
          return this.result.push(new constr(this.getLabel(op.label)));
        }
      } else if (op instanceof idtm.ReturnOperation) {
        if (op.returnvalue != null) {
          this.onstack(op.returnvalue);
        } else {
          this.result.push(new wo.stack.Push(0));
        }
        return this.result.push(new wo.flow.Return);
      } else if (op instanceof idtm.End) {
        return this.result.push(new wo.flow.End);
      } else if (op instanceof idtm.FunctionStart) {
        lb = this.getLabel(op.func);
        return this.result.push(new wo.flow.Label(lb));
      }
    };

    Compiler.prototype.onstack = function(obj) {
      var tmpv;
      if ((obj.type != null) && obj.type === obj.TYPE_STRING) {
        if (obj instanceof idtm.Variable) {
          this.result.push(new wo.stack.Push(this.allocHeap(obj)));
          return;
        } else {
          tmpv = new idtm.Variable;
          tmpv.type = tmpv.TYPE_STRING;
          this.calc(obj, tmpv);
          this.result.push(new wo.stack.Push(this.allocHeap(tmpv)));
          return;
        }
      }
      return this.calc(obj, null);
    };

    Compiler.prototype.calc = function(obj, v) {
      var a, alloctets, args, ato, c, code, endlb, endlb2, i, idx, lb, lb2, lb3, newpos, octets, pos, str, tmpend, tmplb, tmpv, uuuuu, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (obj instanceof idtm.Variable) {
        pos = this.allocHeap(obj);
        if (!((obj.type != null) && obj.type === obj.TYPE_STRING)) {
          this.result.push(new wo.stack.Push(pos));
          this.result.push(new wo.heap.Retrieve);
        } else {
          if (v == null) {
            this.onstack(obj);
            return;
          }
          newpos = this.allocHeap(v);
          this.result.push(new wo.stack.Push(0));
          lb = this.getLabel();
          endlb = this.getLabel();
          this.result.push(new wo.flow.Label(lb));
          this.result.push(new wo.stack.Duplicate);
          this.result.push(new wo.stack.Push(pos));
          this.result.push(new wo.arithmetic.Add);
          this.result.push(new wo.heap.Retrieve);
          this.result.push(new wo.stack.Duplicate);
          this.result.push(new wo.stack.Copy(2));
          this.result.push(new wo.stack.Push(newpos));
          this.result.push(new wo.arithmetic.Add);
          this.result.push(new wo.stack.Swap);
          this.result.push(new wo.heap.Store);
          this.result.push(new wo.flow.JumpZero(endlb));
          this.result.push(new wo.stack.Push(1));
          this.result.push(new wo.arithmetic.Add);
          this.result.push(new wo.flow.Jump(lb));
          this.result.push(new wo.flow.Label(endlb));
          this.result.push(new wo.stack.Discard);
          return;
        }
      } else if (obj instanceof idtm.Literal) {
        if (obj.type === obj.TYPE_STRING) {
          if (v == null) {
            this.onstack(obj);
            return;
          }
          alloctets = [];
          i = 0;
          idx = 0;
          str = obj.value;
          for (i = _i = 0, _ref = str.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            code = str.charCodeAt(i);
            octets = code < 0x80 ? [code] : code < 0x800 ? [0xC0 | ((code >>> 6) & 0x1F), 0x80 | (code & 0x3F)] : code < 0xD7FF || (0xE000 <= code && code < 0x10000) ? [0xE0 | ((code >>> 12) & 0x0F), 0x80 | ((code >>> 6) & 0x3F), 0x80 | (code & 0x3F)] : code <= 0xD800 ? (ato = obj.value.charCodeAt(i + 1), uuuuu = ((code >>> 6) & 0x0F) + 1, [0xF0 | (uuuuu >> 2), 0x80 | ((uuuuu & 3) << 4) | ((code >> 2) & 0x0F), 0x80 | ((code & 3) << 4) | ((ato >> 6) & 0x0F), 0x80 | (ato & 0x3F)]) : [];
            for (_j = 0, _len = octets.length; _j < _len; _j++) {
              c = octets[_j];
              alloctets.push(c);
              idx++;
            }
          }
          alloctets.push(0);
          pos = this.allocHeap(v);
          for (idx = _k = 0, _len1 = alloctets.length; _k < _len1; idx = ++_k) {
            c = alloctets[idx];
            this.result.push(new wo.stack.Push(pos + idx));
            this.result.push(new wo.stack.Push(c));
            this.result.push(new wo.heap.Store);
          }
          return;
        } else {
          this.result.push(new wo.stack.Push(+obj.value));
        }
      } else if (obj instanceof idtm.Calc) {
        if (obj instanceof idtm.Calc1) {
          switch (obj.op) {
            case "to_number":
              if (obj.value.type && obj.value.type === obj.value.TYPE_STRING) {
                throw new Error("文字列を数値に変換できません");
              }
              this.calc(obj.value, v);
              break;
            case "to_boolean":
            case "!":
              if (obj.value.type && obj.value.type === obj.value.TYPE_STRING) {
                this.result.push(new wo.stack.Push(0));
                this.onstack(obj.value);
                this.result.push(new wo.heap.Retrieve);
                tmplb = this.getLabel();
                this.result.push(new wo.flow.JumpZero(tmplb));
                this.result.push(new wo.stack.Discard);
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.flow.Label(tmplb));
              } else {
                if (obj.value.type !== obj.value.TYPE_BOOLEAN) {
                  tmplb = this.getLabel();
                  this.result.push(new wo.stack.Push(0));
                  this.onstack(obj.value);
                  this.result.push(new wo.flow.JumpZero(tmplb));
                  this.result.push(new wo.stack.Discard);
                  this.result.push(new wo.stack.Push(1));
                  this.result.push(new wo.flow.Label(tmplb));
                } else {
                  this.onstack(obj.value);
                }
              }
              if (obj.op === "!") {
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.stack.Swap);
                this.result.push(new wo.arithmetic.Subtract);
              }
              break;
            case "to_string":
              if ((obj.value.type != null) && obj.value.type === obj.value.TYPE_STRING) {
                this.calc(obj.value, v);
                return;
              }
              if (v == null) {
                this.onstack(obj);
                return;
              }
              pos = this.allocHeap(v);
              this.result.push(new wo.stack.Push(0));
              this.onstack(obj.value);
              if ((obj.value.type != null) && obj.value.type === obj.value.TYPE_BOOLEAN) {
                lb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.flow.JumpZero(lb));
                this.result.push(new wo.stack.Push(0x65));
                this.result.push(new wo.stack.Push(0x75));
                this.result.push(new wo.stack.Push(0x72));
                this.result.push(new wo.stack.Push(0x74));
                this.result.push(new wo.flow.Jump(endlb));
                this.result.push(new wo.flow.Label(lb));
                this.result.push(new wo.stack.Push(0x65));
                this.result.push(new wo.stack.Push(0x73));
                this.result.push(new wo.stack.Push(0x6C));
                this.result.push(new wo.stack.Push(0x61));
                this.result.push(new wo.stack.Push(0x66));
                this.result.push(new wo.flow.Label(endlb));
              } else {
                lb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.flow.Label(lb));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Push(10));
                this.result.push(new wo.arithmetic.Modulo);
                this.result.push(new wo.stack.Push(0x30));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.stack.Swap);
                this.result.push(new wo.stack.Push(10));
                this.result.push(new wo.arithmetic.Divide);
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.flow.JumpZero(endlb));
                this.result.push(new wo.flow.Jump(lb));
                this.result.push(new wo.flow.Label(endlb));
                this.result.push(new wo.stack.Discard);
              }
              this.result.push(new wo.stack.Push(0));
              lb2 = this.getLabel();
              endlb2 = this.getLabel();
              this.result.push(new wo.flow.Label(lb2));
              this.result.push(new wo.stack.Duplicate);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.arithmetic.Add);
              this.result.push(new wo.stack.Copy(2));
              this.result.push(new wo.heap.Store);
              this.result.push(new wo.stack.Swap);
              this.result.push(new wo.flow.JumpZero(endlb2));
              this.result.push(new wo.stack.Push(1));
              this.result.push(new wo.arithmetic.Add);
              this.result.push(new wo.flow.Jump(lb2));
              this.result.push(new wo.flow.Label(endlb2));
              this.result.push(new wo.stack.Discard);
              return;
          }
        } else if (obj instanceof idtm.Calc2) {
          switch (obj.punc) {
            case "+":
            case "-":
            case "*":
            case "/":
            case "%":
              if ((obj.type != null) && obj.type === obj.TYPE_STRING) {
                if (obj.punc !== "+") {
                  throw new Error("文字列の計算は加算以外できません");
                }
                if (v == null) {
                  this.onstack(obj);
                  return;
                }
                newpos = this.allocHeap(v);
                if ((obj.val1.type != null) && obj.val1.type === obj.val1.TYPE_STRING) {
                  this.onstack(obj.val1);
                } else {
                  this.onstack(new idtm.Calc1("to_string", obj.val1));
                }
                this.result.push(new wo.stack.Push(0));
                lb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.flow.Label(lb));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(2));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.heap.Retrieve);
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(2));
                this.result.push(new wo.stack.Push(newpos));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.stack.Swap);
                this.result.push(new wo.heap.Store);
                this.result.push(new wo.flow.JumpZero(endlb));
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.flow.Jump(lb));
                this.result.push(new wo.flow.Label(endlb));
                this.result.push(new wo.stack.Slide(1));
                if ((obj.val2.type != null) && obj.val2.type === obj.val2.TYPE_STRING) {
                  this.onstack(obj.val2);
                } else {
                  this.onstack(new idtm.Calc1("to_string", obj.val2));
                }
                this.result.push(new wo.stack.Swap);
                lb2 = this.getLabel();
                endlb2 = this.getLabel();
                this.result.push(new wo.stack.Push(0));
                this.result.push(new wo.flow.Label(lb2));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(3));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.heap.Retrieve);
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(2));
                this.result.push(new wo.stack.Push(newpos));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.stack.Copy(4));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.stack.Swap);
                this.result.push(new wo.heap.Store);
                this.result.push(new wo.flow.JumpZero(endlb2));
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.flow.Jump(lb2));
                this.result.push(new wo.flow.Label(endlb2));
                this.result.push(new wo.stack.Slide(2));
                this.result.push(new wo.stack.Discard);
                return;
              } else {
                this.onstack(obj.val1);
                this.onstack(obj.val2);
                this.result.push((function() {
                  switch (obj.punc) {
                    case "+":
                      return new wo.arithmetic.Add;
                    case "-":
                      return new wo.arithmetic.Subtract;
                    case "*":
                      return new wo.arithmetic.Multiply;
                    case "/":
                      return new wo.arithmetic.Divide;
                    case "%":
                      return new wo.arithmetic.Modulo;
                  }
                })());
              }
              break;
            case "!=":
            case "!==":
              if ((obj.val1.type != null) && obj.val1.type === obj.val1.TYPE_STRING || (obj.val2.type != null) && obj.val2.type === obj.val2.TYPE_STRING) {
                this.call(new idtm.Calc1("!", new idtm.Calc2("==", obj.val1, obj.val2)), v);
                return;
              }
              this.onstack(new idtm.Calc1("to_boolean", new idtm.Calc2("-", obj.val1, obj.val2)));
              break;
            case "==":
            case "===":
              if ((obj.val1.type != null) && obj.val1.type === obj.val1.TYPE_STRING && (obj.val2.type != null) && obj.val2.type === obj.val2.TYPE_STRING) {
                lb = this.getLabel();
                lb2 = this.getLabel();
                lb3 = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.stack.Push(1));
                this.onstack(obj.val1);
                this.onstack(obj.val2);
                this.result.push(new wo.stack.Push(0));
                this.result.push(new wo.flow.Label(lb));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(3));
                this.result.push(new wo.stack.Add);
                this.result.push(new wo.heap.Retrieve);
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(2));
                this.result.push(new wo.stack.Copy(4));
                this.result.push(new wo.stack.Add);
                this.result.push(new wo.heap.Retrieve);
                this.result.push(new wo.arithmetic.Subtract);
                this.result.push(new wo.flow.JumpZero(lb2));
                this.result.push(new wo.stack.Slide(4));
                this.result.push(new wo.stack.Discard);
                this.result.push(new wo.stack.Push(0));
                this.result.push(new wo.flow.Jump(endlb));
                this.result.push(new wo.flow.Label(lb2));
                this.result.push(new wo.stack.JumpZero(lb3));
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.flow.Jump(lb));
                this.result.push(new wo.flow.Label(lb3));
                this.result.push(new wo.flow.Slide(2));
                this.result.push(new wo.stack.Discard);
              } else if ((obj.val1.type != null) && obj.val1.type === obj.val1.TYPE_STRING || (obj.val2.type != null) && obj.val2.type === obj.val2.TYPE_STRING) {
                throw new Error("文字列とそれ以外の等値比較はできません。");
              } else {
                this.onstack(new idtm.Calc1("!", new idtm.Calc2("-", obj.val1, obj.val2)));
              }
              break;
            case ">":
            case ">=":
            case "<":
            case "<=":
              if ((obj.val1.type != null) && obj.val1.type === obj.val1.TYPE_STRING || (obj.val2.type != null) && obj.val2.type === obj.val2.TYPE_STRING) {
                throw new Error("文字列の比較はできません。");
              }
              tmplb = this.getLabel();
              tmpend = this.getLabel();
              switch (obj.punc) {
                case ">":
                case ">=":
                  this.onstack(obj.val2);
                  this.onstack(obj.val1);
                  this.result.push(new wo.arithmetic.Subtract);
                  if (obj.punc === ">=") {
                    this.result.push(new wo.stack.Push(1));
                    this.result.push(new wo.arithmetic.Subtract);
                  }
                  this.result.push(new wo.flow.JumpNegative(tmplb));
                  break;
                case "<":
                case "<=":
                  this.onstack(obj.val1);
                  this.onstack(obj.val2);
                  this.result.push(new wo.arithmetic.Subtract);
                  if (obj.punc === "<=") {
                    this.result.push(new wo.stack.Push(1));
                    this.result.push(new wo.arithmetic.Subtract);
                  }
                  this.result.push(new wo.flow.JumpNegative(tmplb));
              }
              this.result.push(new wo.stack.Push(0));
              this.result.push(new wo.flow.Jump(tmpend));
              this.result.push(new wo.flow.Label(tmplb));
              this.result.push(new wo.stack.Push(1));
              this.result.push(new wo.flow.Label(tmpend));
              break;
            case "||":
              this.onstack(new idtm.Calc1("to_boolean", obj.val1));
              this.onstack(new idtm.Calc1("to_boolean", obj.val2));
              this.result.push(new wo.arithmetic.Add);
              this.result.push(new wo.stack.Duplicate);
              this.resuht.push(new wo.stack.Push(2));
              this.result.push(new wo.arithmetic.Subtract);
              this.result.push(new wo.stack.Push(1));
              tmplb = this.getLabel();
              this.result.push(new wo.flow.JumpZero(tmplb));
              this.result.push(new wo.stack.Discard);
              this.resutl.push(new wo.stack.Push(0));
              break;
            case "&&":
              this.onstack(new idtm.Calc1("to_boolean", obj.val1));
              this.onstack(new idtm.Calc1("to_boolean", obj.val2));
              this.result.push(new wo.arithmetic.Multiply);
          }
        } else if (obj instanceof idtm.Call) {
          if (obj.func instanceof idtm.NativeFunc) {
            if (obj.func instanceof idtm.Print) {
              a = obj.args[0];
              if (a == null) {
                throw new Error("printの引数がありません。");
              }
              /*
              if a instanceof idtm.Calc2
                  if a.type? && a.type==a.TYPE_STRING && a.punc=="+"
                      # 文字列連結だ
                      # 分解する
                      @onstack new idtm.Call new idtm.Print,[a.val1]
                      @onstack new idtm.Call new idtm.Print,[a.val2]
                      @result.push new wo.stack.Discard
                      return
              */

              if ((a.type != null) && ((_ref1 = a.type) === a.TYPE_STRING || _ref1 === a.TYPE_BOOLEAN)) {
                if (a.type === a.TYPE_BOOLEAN) {
                  this.onstack(new idtm.Calc1("to_string", a));
                } else {
                  this.onstack(a);
                }
                tmplb = this.getLabel();
                endlb = this.getLabel();
                this.result.push(new wo.stack.Push(0));
                this.result.push(new wo.flow.Label(tmplb));
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.stack.Copy(2));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.heap.Retrieve);
                this.result.push(new wo.stack.Duplicate);
                this.result.push(new wo.flow.JumpZero(endlb));
                this.result.push(new wo.io.OutputChar);
                this.result.push(new wo.stack.Push(1));
                this.result.push(new wo.arithmetic.Add);
                this.result.push(new wo.flow.Jump(tmplb));
                this.result.push(new wo.flow.Label(endlb));
                this.result.push(new wo.stack.Slide(2));
              } else if (a instanceof idtm.Variable && a.type === a.TYPE_UNKNOWN) {
                throw new Error("変数" + ((_ref2 = a.name) != null ? _ref2 : '') + "の型を特定できないのでprintできません。");
              } else {
                this.onstack(a);
                this.result.push(new wo.io.OutputNumber);
                this.result.push(new wo.stack.Push(0));
              }
            } else if (obj.func instanceof idtm.Charcode) {
              a = obj.args[0];
              if (a == null) {
                throw new Error("charcodeの引数がありません。");
              }
              this.onstack(a);
              if ((a.type != null) && a.type === a.TYPE_STRING) {
                this.result.push(new wo.heap.Retrieve);
              }
            } else if (obj.func instanceof idtm.InputChar) {
              tmpv = new idtm.Variable;
              pos = this.allocHeap(tmpv);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.io.ReadChar);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.heap.Retrieve);
            } else if (obj.func instanceof idtm.InputNumber) {
              tmpv = new idtm.Variable;
              pos = this.allocHeap(tmpv);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.io.ReadNumber);
              this.result.push(new wo.stack.Push(pos));
              this.result.push(new wo.heap.Retrieve);
            } else {
              throw new Error("ん？");
            }
          } else {
            lb = this.getLabel(obj.func);
            args = obj.args;
            _ref3 = obj.func.start.vars;
            for (i = _l = 0, _len2 = _ref3.length; _l < _len2; i = ++_l) {
              v = _ref3[i];
              if (args[i] == null) {
                throw new Error("引数が足りません");
              }
              this.calc(args[i], v);
              if (args[i].type != null) {
                if (v.type != null) {
                  if (args[i].type !== v.type) {
                    v.type = v.TYPE_UNKNOWN;
                  }
                } else {
                  v.type = args[i].type;
                }
              }
            }
            this.result.push(new wo.flow.Call(lb));
          }
        }
      }
      if (v != null) {
        pos = this.allocHeap(v);
        this.result.push(new wo.stack.Push(pos));
        this.result.push(new wo.stack.Swap);
        return this.result.push(new wo.heap.Store);
      }
    };

    Compiler.prototype.getLabel = function(lb) {
      var thislabel;
      thislabel = this.myLabelnumber;
      if (lb instanceof idtm.Label) {
        if (this.labels[lb.number] != null) {
          return this.labels[lb.number];
        } else {
          this.labels[lb.number] = this.numberToLabelstring(thislabel);
          this.myLabelnumber++;
          return this.labels[lb.number];
        }
      } else if (lb instanceof idtm.Func) {
        if (lb.label != null) {
          return lb.label;
        }
        lb.label = this.numberToLabelstring(thislabel);
        this.myLabelnumber++;
        return lb.label;
      } else {
        this.myLabelnumber++;
        return this.numberToLabelstring(thislabel);
      }
    };

    Compiler.prototype.allocHeap = function(v) {
      var heappos, i, j, len, va, _i, _ref;
      if (v.size == null) {
        if (v.type === v.TYPE_STRING) {
          v.size = 256;
        } else {
          v.size = 1;
        }
      }
      heappos = null;
      i = 0;
      len = this.heap.length;
      while (i < len) {
        va = this.heap[i];
        if (v === va) {
          return i;
        }
        i += va.size;
      }
      i = 0;
      while (true) {
        va = this.heap[i];
        if (va == null) {
          heappos = i;
          for (j = _i = 1, _ref = v.size; 1 <= _ref ? _i < _ref : _i > _ref; j = 1 <= _ref ? ++_i : --_i) {
            if (this.heap[i + j] != null) {
              heappos = null;
              break;
            }
          }
          if (heappos != null) {
            break;
          }
        }
        i += va.size;
      }
      if (heappos == null) {
        heappos = this.heap.length;
      }
      this.heap[heappos] = v;
      return heappos;
    };

    Compiler.prototype.numberToLabelstring = function(num) {
      var result;
      result = "";
      while (num > 0) {
        if (num % 2 === 1) {
          result = "\t" + result;
          num--;
        } else {
          result = " " + result;
        }
        num /= 2;
      }
      if (result === "") {
        result = " ";
      }
      return result;
    };

    return Compiler;

  })();

  exports.Compiler = Compiler;

}).call(this);
