// Generated by CoffeeScript 1.6.3
(function() {
  var Calc, Calc1, Calc2, Call, Charcode, Closure, CodeToString, Compiler, End, Func, FunctionStart, GlobalClosure, InputChar, InputNumber, IterationManager, JumpOperation, JumpifOperation, JumpunlessOperation, Label, Literal, NativeFunc, Operation, Print, ReturnOperation, SubstituteOperation, Variable, parser, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  parser = require('./parser');

  Closure = (function() {
    function Closure(parent) {
      this.parent = parent;
      this.variables = {};
      this.functions = {};
    }

    Closure.prototype.getNewLabel = function() {
      if (this.parent) {
        return this.parent.getNewLabel();
      } else {
        return null;
      }
    };

    Closure.prototype.getChild = function() {
      return new Closure(this);
    };

    Closure.prototype.getVariable = function(name) {
      var v;
      if (v = this.getLocalVariable(name)) {
        return v;
      } else if (this.parent != null) {
        return this.parent.getLocalVariable(name);
      } else {
        return null;
      }
    };

    Closure.prototype.getLocalVariable = function(name) {
      if (this.variables[name] != null) {
        return this.variables[name];
      }
      return null;
    };

    Closure.prototype.addVariable = function(v) {
      if (this.parent) {
        return this.parent.addVariable(v);
      } else {
        return this.addLocalVariable(v);
      }
    };

    Closure.prototype.addLocalVariable = function(v) {
      if (v.name != null) {
        return this.variables[v.name] = v;
      }
    };

    Closure.prototype.addFunction = function(func) {
      if (func.name != null) {
        return this.functions[func.name] = func;
      }
    };

    Closure.prototype.getFunction = function(name) {
      var _ref, _ref1;
      return (_ref = this.functions[name]) != null ? _ref : (_ref1 = this.parent) != null ? _ref1.getFunction(name) : void 0;
    };

    return Closure;

  })();

  GlobalClosure = (function(_super) {
    __extends(GlobalClosure, _super);

    function GlobalClosure() {
      GlobalClosure.__super__.constructor.call(this, null);
      this.labels = [];
      this.nextLabelNumber = 0;
    }

    GlobalClosure.prototype.getNewLabel = function() {
      var n;
      n = new Label(this.nextLabelNumber++);
      this.labels.push(n);
      return n;
    };

    return GlobalClosure;

  })(Closure);

  Compiler = (function() {
    function Compiler() {
      this.closure = new GlobalClosure;
      this.result = [];
      this.reservedLabelNames = [];
      this.iterationStack = [];
      this.funcStack = [];
      this.tma = new parser.TokenizeManager;
    }

    Compiler.prototype.compile = function(statements) {
      this.statements(statements, true);
      return this.result;
    };

    Compiler.prototype.statements = function(obj, mainmode) {
      var el, f, funcs, _i, _j, _len, _len1, _results;
      if (obj instanceof parser.Statements) {
        funcs = [];
        if (obj instanceof parser.SourceElements) {
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            el = obj[_i];
            if (el instanceof parser.FunctionDeclaration) {
              funcs.push(this.closure.addFunction(this.makeFunction(el)));
            }
          }
        }
        obj.forEach(this.main.bind(this));
        if (mainmode) {
          this.result.push(new End);
        }
        _results = [];
        for (_j = 0, _len1 = funcs.length; _j < _len1; _j++) {
          f = funcs[_j];
          _results.push(this.codeFunction(f));
        }
        return _results;
      }
    };

    Compiler.prototype.main = function(obj) {
      var backlabel, cond, cres, endlabel, exp, f, falselabel, nextlabel, tmpv, v, vararr, vari, _i, _len, _ref, _ref1, _ref2,
        _this = this;
      if (obj instanceof parser.BlockStatement) {
        this.statements(obj.statements, false);
      } else if (obj instanceof parser.VariableStatement) {
        _ref = obj.variables;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vararr = _ref[_i];
          v = this.getLocalVariable(vararr[0].value);
          if (vararr[1] != null) {
            this.substitute(v, this.calc(vararr[1]));
          }
        }
      } else if (obj instanceof parser.EmptyStatement) {

      } else if (obj instanceof parser.ExpressionStatement) {
        cres = this.calc(obj.exp);
        if (!(cres instanceof Variable && (cres.name != null))) {
          tmpv = this.getTempVariable();
          this.substitute(tmpv, cres);
        }
      } else if (obj instanceof parser.IfStatement) {
        falselabel = this.getNewLabel();
        endlabel = null;
        cond = this.calc(obj.condition);
        this.jumpunless(cond, falselabel);
        this.main(obj.truestatement);
        if (obj.elsestatement != null) {
          endlabel = this.getNewLabel();
          this.jump(endlabel);
        }
        this.labelhere(falselabel);
        if (obj.elsestatement != null) {
          this.main(obj.elsestatement);
          this.labelhere(endlabel);
        }
      } else if (obj instanceof parser.Do_WhileStatement) {
        backlabel = this.getNewLabel();
        endlabel = this.getNewLabel();
        this.labelhere(backlabel);
        this.manageIteration((function() {
          _this.main(obj.statement);
          cond = _this.calc(obj.condition);
          _this.jumpif(cond, backlabel);
          return _this.labelhere(endlabel);
        }), (function() {
          return _this.jump(backlabel);
        }), (function() {
          return _this.jump(endlabel);
        }));
      } else if (obj instanceof parser.WhileStatement) {
        backlabel = this.getNewLabel();
        endlabel = this.getNewLabel();
        this.manageIteration((function() {
          _this.labelhere(backlabel);
          cond = _this.calc(obj.condition);
          _this.jumpunless(cond, endlabel);
          _this.main(obj.statement);
          _this.jump(backlabel);
          return _this.labelhere(endlabel);
        }), (function() {
          return _this.jump(backlabel);
        }), (function() {
          return _this.jump(endlabel);
        }));
      } else if (obj instanceof parser.ForStatement) {
        if (obj.exp1 != null) {
          this.calc(obj.exp1);
        }
        backlabel = this.getNewLabel();
        nextlabel = this.getNewLabel();
        endlabel = this.getNewLabel();
        this.manageIteration((function() {
          _this.labelhere(backlabel);
          cond = obj.exp2 != null ? _this.calc(obj.exp2) : new Literal(true);
          _this.jumpunless(cond, endlabel);
          _this.main(obj.statement);
          _this.labelhere(nextlabel);
          if (obj.exp3 != null) {
            _this.calc(obj.exp3);
          }
          _this.jump(backlabel);
          return _this.labelhere(endlabel);
        }), (function() {
          return _this.jump(nextlabel);
        }), (function() {
          return _this.jump(endlabel);
        }));
      } else if (obj instanceof parser.For_VarStatement) {
        vari = new parser.VariableStatement;
        vari.variables = obj.variables;
        this.main(vari);
        backlabel = this.getNewLabel();
        nextlabel = this.getNewLabel();
        endlabel = this.getNewLabel();
        this.manageIteration((function() {
          _this.labelhere(backlabel);
          cond = obj.exp2 != null ? _this.calc(obj.exp2) : new Literal(true);
          _this.jumpunless(cond, endlabel);
          _this.main(obj.statement);
          _this.labelhere(nextlabel);
          if (obj.exp3 != null) {
            _this.calc(obj.exp3);
          }
          _this.jump(backlabel);
          return _this.labelhere(endlabel);
        }), (function() {
          return _this.jump(nextlabel);
        }), (function() {
          return _this.jump(endlabel);
        }));
      } else if (obj instanceof parser.For_InStatement) {
        throw new Error("for-in文は対応していません");
      } else if (obj instanceof parser.For_In_VarStatement) {
        throw new Error("for-in文は対応していません");
      } else if (obj instanceof parser.ContinueStatement) {
        this.docontinue((_ref1 = obj.identifier) != null ? _ref1.value : void 0);
      } else if (obj instanceof parser.BreakStatement) {
        this.dobreak((_ref2 = obj.identifier) != null ? _ref2.value : void 0);
      } else if (obj instanceof parser.ReturnStatement) {
        f = this.funcStack[this.funcStack.length - 1];
        if (f == null) {
          throw new Error("関数外でreturnは使用できません");
        }
        if (obj.exp != null) {
          this.result.push(new ReturnOperation(f, this.calc(obj.exp)));
        } else {
          this.result.push(new ReturnOperation);
        }
      } else if (obj instanceof parser.WithStatement) {
        throw new Error("with文は対応していません");
      } else if (obj instanceof parser.SwitchStatement) {
        exp = this.calc(obj.exp);
        endlabel = this.getNewLabel();
        this.manageIteration((function() {
          var arr, default_flg, i, labels, _j, _k, _l, _len1, _len2, _len3, _ref3, _ref4, _ref5;
          labels = [];
          default_flg = false;
          _ref3 = obj.cases;
          for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
            arr = _ref3[i];
            labels[i] = _this.getNewLabel();
            if (!arr[2]) {
              _this.jumpif(new Calc2("===", exp, _this.calc(arr[0])), labels[i]);
            } else {
              default_flg = true;
            }
          }
          if (default_flg) {
            _ref4 = obj.cases;
            for (i = _k = 0, _len2 = _ref4.length; _k < _len2; i = ++_k) {
              arr = _ref4[i];
              if (arr[2]) {
                _this.jump(labels[i]);
              }
            }
          }
          _ref5 = obj.cases;
          for (i = _l = 0, _len3 = _ref5.length; _l < _len3; i = ++_l) {
            arr = _ref5[i];
            _this.labelhere(labels[i]);
            _this.statements(arr[1]);
          }
          return _this.labelhere(endlabel);
        }), null, (function() {
          return _this.jump(endlabel);
        }));
      } else if (obj instanceof parser.LabelledStatement) {
        if ((obj.statement instanceof parser.IterationStatement) || (obj.statement instanceof parser.SwitchStatement)) {
          this.reservedLabelNames.push(obj.identifier.name);
        }
        this.main(obj.statement);
      } else if (obj instanceof parser.ThrowStatement) {
        throw new Error("throw文は対応していません");
      } else if (obj instanceof parser.TryStatement) {
        throw new Error("try文は対応していません");
      } else if (obj instanceof parser.DebuggerStatement) {

      } else if (obj instanceof parser.FunctionDeclaration) {

      } else {
        throw new Error("は？ " + (obj.tokenize(this.tma)));
      }
    };

    Compiler.prototype.calc = function(exp, newvmode) {
      var f, first, key, lit, lstr, res, second, table, v, val;
      first = exp.parts[0];
      if (first instanceof parser.Expression) {
        if (exp.parts.length === 1) {
          return this.calc(first);
        }
        second = exp.parts[1];
        if (second instanceof parser.PunctuatorToken || second instanceof parser.KeywordToken) {
          if (exp.parts.length === 2) {
            return this.calc1after(first, exp.parts[1]);
          }
          return this.calc2(first, second, exp.parts[2]);
        }
        if (second instanceof parser.Arguments && exp.parts.length === 2) {
          return this.callfunc(first, second);
        }
      } else if (first instanceof parser.PunctuatorToken) {
        if (exp.parts.length === 2) {
          return this.calc1before(exp.parts[1], first);
        }
        if (exp.parts.length === 3 && first.value === "(" && exp.parts[2].value === ")") {
          return this.calc(exp.parts[1]);
        }
        throw new Error("解釈できません");
      } else if (exp.parts.length === 1) {
        if (first instanceof parser.IdentifierToken) {
          v = this.closure.getVariable(first.value);
          if (v == null) {
            if (newvmode) {
              v = new Variable(first.value);
              this.closure.addVariable(v);
              return v;
            }
            f = this.closure.getFunction(first.value);
            if (f != null) {
              return f;
            }
            switch (first.value) {
              case "print":
                return new Print;
              case "charCode":
                return new Charcode;
              case "inputChar":
                return new InputChar;
              case "inputNumber":
                return new InputNumber;
              case "codeToString":
                return new CodeToString;
            }
            throw new Error("Undefined variable " + first.value);
          }
          return v;
        } else if (first instanceof parser.RegExpLiteralToken) {
          throw new Error("正規表現リテラルは使用できません");
        } else if (first instanceof parser.StringLiteralToken) {
          res = first.value.match(/^[\"\'](.*)[\"\']$/);
          if (res == null) {
            throw new Error("えっ文字列リテラルじゃないの " + first.value);
          }
          lstr = res[1];
          table = {
            "\\b": "\b",
            "\\f": "\f",
            "\\r": "\r",
            "\\n": "\n",
            "\\t": "\t",
            "\\v": "\v",
            "\\'": "'",
            "\\\"": "\"",
            "\\\\": "\\"
          };
          for (key in table) {
            val = table[key];
            lstr = lstr.replace(key, val);
          }
          lstr = lstr.replace("\\([0-7]{1,3})", function(all, num8) {
            return String.fromCharCode(parseInt(num8, 8));
          });
          lstr = lstr.replace("\\x([0-9a-fA-F]{2})", function(all, num16) {
            return String.fromCharCode(parseInt(num16, 16));
          });
          lstr = lstr.replace("\\u([0-9a-fA-F]{4})", function(all, num16) {
            return String.fromCharCode(parseInt(num16, 16));
          });
          return new Literal(lstr);
        } else if (first instanceof parser.LiteralToken) {
          lit = (function() {
            var _ref, _ref1;
            if ((_ref = first.value) === "true" || _ref === "false") {
              return new Literal((first.value === "true" ? true : false));
            } else if ((_ref1 = first.value) === "null" || _ref1 === "undefined") {
              throw new Error("null,undefinedは使用できません");
            } else {
              return new Literal(parseInt(first.value));
            }
          })();
          return lit;
        }
      } else {
        throw new Error("は？？");
      }
    };

    Compiler.prototype.calc1before = function(exp, punc) {
      var bu, ca, nu, v;
      v = this.calc(exp);
      punc = punc.value || punc;
      switch (punc) {
        case "++":
        case "--":
          if (!(v instanceof Variable && v.name)) {
            throw new Error("代入できません");
          }
          ca = punc === "++" ? new Calc2("+", v, new Literal(1)) : new Calc2("-", v, new Literal(1));
          this.substitute(v, ca);
          return v;
        case "+":
          return this.tonumber(v);
        case "-":
          nu = this.tonumber(v);
          return new Calc2("*", nu, new Literal(-1));
        case "!":
          bu = this.toboolean(v);
          return new Calc1("!", bu);
        default:
          throw new Error("演算子" + punc + "は使用できません。");
      }
    };

    Compiler.prototype.calc1after = function(exp, punc) {
      var ca, v, v2;
      v = this.calc(exp);
      punc = punc.value || punc;
      switch (punc) {
        case "++":
        case "--":
          if (!(v instanceof Variable && v.name)) {
            throw new Error("代入できません");
          }
          v2 = this.getTempVariable();
          this.substitute(v2, v);
          ca = punc === "++" ? new Calc2("+", v, new Literal(1)) : new Calc2("-", v, new Literal(1));
          this.substitute(v, ca);
          return v2;
        default:
          throw new Error("演算子" + punc + "は使用できません。");
      }
    };

    Compiler.prototype.calc2 = function(mae, punc, ato) {
      var a, res, v;
      punc = punc.value || punc;
      switch (punc) {
        case ",":
          this.calc(mae);
          return this.calc(ato);
        case "+=":
        case "-=":
        case "*=":
        case "/=":
        case "%=":
          v = this.calc(mae);
          if (!(v instanceof Variable && v.name)) {
            throw new Error("代入できません。");
          }
          a = this.calc(ato);
          this.substitute(v, new Calc2(punc[0], v, a));
          return v;
        case "=":
          v = this.calc(mae, true);
          if (!(v instanceof Variable && v.name)) {
            throw new Error("代入できません。");
          }
          a = this.calc(ato);
          this.substitute(v, a);
          return v;
        case "!=":
        case "!==":
        case "==":
        case "===":
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case ">":
        case ">=":
        case "<=":
        case "<":
        case "|":
        case "&":
        case "^":
        case "||":
        case "&&":
          mae = this.calc(mae);
          ato = this.calc(ato);
          res = this.getTempVariable();
          this.substitute(res, new Calc2(punc, mae, ato));
          return res;
        default:
          throw new Error("演算子" + punc + "は使用できません。");
      }
    };

    Compiler.prototype.callfunc = function(exp, args) {
      var e, f;
      f = this.calc(exp);
      if (!(f instanceof Func)) {
        throw new Error("関数ではありません。");
      }
      return new Call(f, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          e = args[_i];
          _results.push(this.calc(e));
        }
        return _results;
      }).call(this));
    };

    Compiler.prototype.makeFunction = function(func) {
      var res;
      res = new Func(func.name, func.paramlist, func.functionbody);
      switch (func.returnType) {
        case "number":
          res.type = res.TYPE_NUMBER;
          break;
        case "string":
          res.type = res.TYPE_STRING;
          break;
        case "boolean":
          res.type = res.TYPE_BOOLEAN;
      }
      return res;
    };

    Compiler.prototype.codeFunction = function(func) {
      var pi, v, _i, _len, _ref;
      this.closure = this.closure.getChild();
      func.start.vars = [];
      _ref = func.paramlist;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pi = _ref[_i];
        v = this.getLocalVariable(pi.value);
        func.start.vars.push(v);
      }
      this.funcStack.push(func);
      this.result.push(func.start);
      this.statements(func.functionbody, false);
      this.result.push(new ReturnOperation(func));
      this.funcStack.pop();
      return this.closure = this.closure.parent;
    };

    Compiler.prototype.tonumber = function(val) {
      var re;
      if (val instanceof Literal) {
        switch (val.type) {
          case val.TYPE_NUMBER:
            return val;
          case val.TYPE_STRING:
            re = parseInt(val.value);
            if (isNaN(re)) {
              throw new Error(JSON.stringify(val.value) + "は数値に変換できません。");
            }
            return new Literal(re);
          case val.TYPE_BOOLEAN:
            return new Literal(+val.value);
        }
      } else {
        return new Calc1("to_number", val);
      }
    };

    Compiler.prototype.toboolean = function(val) {
      if (val instanceof Literal) {
        switch (val.type) {
          case val.TYPE_NUMBER:
          case val.TYPE_STRING:
            return new Literal(!!val.value);
          case val.TYPE_BOOLEAN:
            return val;
        }
      } else {
        return new Calc1("to_boolean", val);
      }
    };

    Compiler.prototype.substitute = function(v, value) {
      if (value instanceof Variable || value instanceof Literal || value instanceof Calc) {
        v.type = value.type;
      }
      return this.result.push(new SubstituteOperation(v, value));
    };

    Compiler.prototype.jump = function(label) {
      return this.result.push(new JumpOperation(label));
    };

    Compiler.prototype.jumpif = function(cond, label) {
      return this.result.push(new JumpifOperation(cond, label));
    };

    Compiler.prototype.jumpunless = function(cond, label) {
      return this.result.push(new JumpunlessOperation(cond, label));
    };

    Compiler.prototype.labelhere = function(label) {
      return this.result.push(label);
    };

    Compiler.prototype.manageIteration = function(main, cont, br) {
      var o;
      o = new IterationManager(main, cont, br, this.reservedLabelNames);
      this.reservedLabelNames = [];
      this.iterationStack.push(o);
      main();
      return this.iterationStack.pop();
    };

    Compiler.prototype.docontinue = function(labelName) {
      var flag, it, _i, _ref;
      flag = false;
      _ref = this.iterationStack;
      for (_i = _ref.length - 1; _i >= 0; _i += -1) {
        it = _ref[_i];
        if (!labelName || (__indexOf.call(it.labelNames, labelName) >= 0)) {
          if (it.cont != null) {
            flag = true;
            it.cont();
            break;
          }
        }
      }
      if (!flag) {
        throw new Error("ループ外でcontinueは使用できません。");
      }
    };

    Compiler.prototype.dobreak = function(labelName) {
      var flag, it, _i, _ref;
      flag = false;
      _ref = this.iterationStack;
      for (_i = _ref.length - 1; _i >= 0; _i += -1) {
        it = _ref[_i];
        if (!labelName || (__indexOf.call(it.labelNames, labelName) >= 0)) {
          if (it.br != null) {
            flag = true;
            it.br();
            break;
          }
        }
      }
      if (!flag) {
        throw new Error("ループ外でbreakは使用できません。");
      }
    };

    Compiler.prototype.getLocalVariable = function(name) {
      var v;
      v = this.closure.getLocalVariable(name);
      if (v != null) {
        return v;
      }
      v = new Variable(name);
      this.closure.addLocalVariable(v);
      return v;
    };

    Compiler.prototype.getTempVariable = function() {
      var v;
      v = new Variable(null);
      this.closure.addLocalVariable(v);
      return v;
    };

    Compiler.prototype.getNewLabel = function() {
      return this.closure.getNewLabel();
    };

    return Compiler;

  })();

  IterationManager = (function() {
    function IterationManager(main, cont, br, labelNames) {
      this.main = main;
      this.cont = cont;
      this.br = br;
      this.labelNames = labelNames;
    }

    return IterationManager;

  })();

  Operation = (function() {
    function Operation() {}

    return Operation;

  })();

  Label = (function(_super) {
    __extends(Label, _super);

    function Label(number) {
      this.number = number;
    }

    return Label;

  })(Operation);

  SubstituteOperation = (function(_super) {
    __extends(SubstituteOperation, _super);

    function SubstituteOperation(v, value) {
      this.v = v;
      this.value = value;
    }

    return SubstituteOperation;

  })(Operation);

  JumpOperation = (function(_super) {
    __extends(JumpOperation, _super);

    function JumpOperation(label) {
      this.label = label;
    }

    return JumpOperation;

  })(Operation);

  JumpifOperation = (function(_super) {
    __extends(JumpifOperation, _super);

    function JumpifOperation(cond, label) {
      this.cond = cond;
      this.label = label;
    }

    return JumpifOperation;

  })(Operation);

  JumpunlessOperation = (function(_super) {
    __extends(JumpunlessOperation, _super);

    function JumpunlessOperation(cond, label) {
      this.cond = cond;
      this.label = label;
    }

    return JumpunlessOperation;

  })(Operation);

  ReturnOperation = (function(_super) {
    __extends(ReturnOperation, _super);

    function ReturnOperation(func, returnvalue) {
      this.func = func;
      this.returnvalue = returnvalue;
    }

    return ReturnOperation;

  })(Operation);

  End = (function(_super) {
    __extends(End, _super);

    function End() {
      _ref = End.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return End;

  })(Operation);

  Variable = (function() {
    Variable.prototype.TYPE_NUMBER = 1;

    Variable.prototype.TYPE_STRING = 2;

    Variable.prototype.TYPE_BOOLEAN = 3;

    Variable.prototype.TYPE_UNKNOWN = 4;

    function Variable(name) {
      this.name = name;
      this.type = null;
    }

    return Variable;

  })();

  Literal = (function() {
    Literal.prototype.TYPE_NUMBER = 1;

    Literal.prototype.TYPE_STRING = 2;

    Literal.prototype.TYPE_BOOLEAN = 3;

    function Literal(value) {
      this.value = value;
      this.type = null;
      switch (typeof this.value) {
        case "string":
          this.type = this.TYPE_STRING;
          break;
        case "number":
          this.type = this.TYPE_NUMBER;
          break;
        case "boolean":
          this.type = this.TYPE_BOOLEAN;
      }
    }

    return Literal;

  })();

  Calc = (function() {
    Calc.prototype.TYPE_NUMBER = 1;

    Calc.prototype.TYPE_STRING = 2;

    Calc.prototype.TYPE_BOOLEAN = 3;

    Calc.prototype.TYPE_UNKNOWN = 4;

    function Calc() {
      this.type = null;
    }

    return Calc;

  })();

  Calc1 = (function(_super) {
    __extends(Calc1, _super);

    function Calc1(op, value) {
      this.op = op;
      this.value = value;
      this.type = null;
      switch (this.op) {
        case "to_number":
          this.type = this.TYPE_NUMBER;
          break;
        case "to_boolean":
        case "!":
          this.type = this.TYPE_BOOLEAN;
          break;
        case "to_string":
          this.type = this.TYPE_STRING;
      }
    }

    return Calc1;

  })(Calc);

  Calc2 = (function(_super) {
    __extends(Calc2, _super);

    function Calc2(punc, val1, val2) {
      this.punc = punc;
      this.val1 = val1;
      this.val2 = val2;
      this.type = null;
      switch (this.punc) {
        case "+":
          if (val1.type === val1.TYPE_STRING || val2.type === val2.TYPE_STRING) {
            this.type = this.TYPE_STRING;
          } else {
            this.type = this.TYPE_NUMBER;
          }
          break;
        case "-":
        case "*":
        case "/":
        case "%":
          this.type = this.TYPE_NUMBER;
          break;
        case "!=":
        case "!==":
        case "==":
        case "===":
        case ">":
        case ">=":
        case "<=":
        case "<":
        case "||":
        case "&&":
          this.type = this.TYPE_BOOLEAN;
      }
    }

    return Calc2;

  })(Calc);

  Func = (function() {
    Func.prototype.TYPE_NUMBER = 1;

    Func.prototype.TYPE_STRING = 2;

    Func.prototype.TYPE_BOOLEAN = 3;

    Func.prototype.TYPE_UNKNOWN = 4;

    function Func(name, paramlist, functionbody) {
      this.name = name;
      this.paramlist = paramlist;
      this.functionbody = functionbody;
      this.type = null;
      this.start = new FunctionStart(this);
    }

    return Func;

  })();

  FunctionStart = (function(_super) {
    __extends(FunctionStart, _super);

    function FunctionStart(func) {
      this.func = func;
      this.vars = [];
    }

    return FunctionStart;

  })(Operation);

  Call = (function(_super) {
    __extends(Call, _super);

    Call.prototype.TYPE_NUMBER = 1;

    Call.prototype.TYPE_STRING = 2;

    Call.prototype.TYPE_BOOLEAN = 3;

    Call.prototype.TYPE_UNKNOWN = 4;

    function Call(func, args) {
      this.func = func;
      this.args = args;
      if (this.func.type != null) {
        this.type = this.func.type;
      }
    }

    return Call;

  })(Calc);

  NativeFunc = (function(_super) {
    __extends(NativeFunc, _super);

    function NativeFunc() {
      _ref1 = NativeFunc.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return NativeFunc;

  })(Func);

  Print = (function(_super) {
    __extends(Print, _super);

    function Print() {
      Print.__super__.constructor.call(this, "print", [], null);
      this.type = this.TYPE_NUMBER;
    }

    return Print;

  })(NativeFunc);

  Charcode = (function(_super) {
    __extends(Charcode, _super);

    function Charcode() {
      Charcode.__super__.constructor.call(this, "charCode", [], null);
      this.type = this.TYPE_NUMBER;
    }

    return Charcode;

  })(NativeFunc);

  InputChar = (function(_super) {
    __extends(InputChar, _super);

    function InputChar() {
      InputChar.__super__.constructor.call(this, "inputChar", [], null);
      this.type = this.TYPE_NUMBER;
    }

    return InputChar;

  })(NativeFunc);

  InputNumber = (function(_super) {
    __extends(InputNumber, _super);

    function InputNumber() {
      InputNumber.__super__.constructor.call(this, "inputNumber", [], null);
      this.type = this.TYPE_NUMBER;
    }

    return InputNumber;

  })(NativeFunc);

  CodeToString = (function(_super) {
    __extends(CodeToString, _super);

    function CodeToString() {
      CodeToString.__super__.constructor.call(this, "codeToString", [], null);
      this.type = this.TYPE_STRING;
    }

    return CodeToString;

  })(NativeFunc);

  exports.Compiler = Compiler;

  exports.Operation = Operation;

  exports.Label = Label;

  exports.SubstituteOperation = SubstituteOperation;

  exports.JumpOperation = JumpOperation;

  exports.JumpifOperation = JumpifOperation;

  exports.JumpunlessOperation = JumpunlessOperation;

  exports.ReturnOperation = ReturnOperation;

  exports.End = End;

  exports.Variable = Variable;

  exports.Literal = Literal;

  exports.Calc = Calc;

  exports.Calc1 = Calc1;

  exports.Calc2 = Calc2;

  exports.Func = Func;

  exports.FunctionStart = FunctionStart;

  exports.Call = Call;

  exports.NativeFunc = NativeFunc;

  exports.Print = Print;

  exports.Charcode = Charcode;

  exports.InputChar = InputChar;

  exports.InputNumber = InputNumber;

  exports.CodeToString = CodeToString;

}).call(this);
