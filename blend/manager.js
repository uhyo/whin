// Generated by CoffeeScript 1.6.3
(function() {
  var Blender, Indent, Just, NewLine, WSBuffer, WSManager, WSToken, parser, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  parser = require('../js/parser');

  WSManager = (function(_super) {
    __extends(WSManager, _super);

    function WSManager() {
      _ref = WSManager.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    WSManager.prototype.just = function() {
      return new Just;
    };

    WSManager.prototype.indent = function(tokenlist) {
      var flg, ret, t, _i, _len;
      ret = new tokenlist.constructor;
      flg = true;
      for (_i = 0, _len = tokenlist.length; _i < _len; _i++) {
        t = tokenlist[_i];
        if (flg) {
          flg = false;
          if (t instanceof Indent) {
            ret.push(new Indent(t.level + 1));
          } else {
            ret.push(new Indent(1));
            ret.push(t);
          }
        } else {
          ret.push(t);
        }
        if (t instanceof NewLine) {
          flg = true;
        }
      }
      return ret;
    };

    WSManager.prototype.newline = function() {
      return new NewLine;
    };

    WSManager.prototype.chomp = function(tokenlist) {
      var t, _i;
      for (_i = tokenlist.length - 1; _i >= 0; _i += -1) {
        t = tokenlist[_i];
        if (t instanceof NewLine) {
          tokenlist.pop();
        } else {
          break;
        }
      }
      return tokenlist;
    };

    return WSManager;

  })(parser.TokenizeManager);

  WSToken = (function() {
    function WSToken() {}

    WSToken.prototype.likeIdentifier = function() {
      return false;
    };

    return WSToken;

  })();

  Just = (function(_super) {
    __extends(Just, _super);

    function Just() {
      _ref1 = Just.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Just.prototype.toString = function() {
      return "[Just]";
    };

    return Just;

  })(WSToken);

  Indent = (function(_super) {
    __extends(Indent, _super);

    function Indent(level) {
      this.level = level;
    }

    Indent.prototype.toString = function() {
      return "[Indent" + this.level + "]";
    };

    return Indent;

  })(WSToken);

  NewLine = (function(_super) {
    __extends(NewLine, _super);

    function NewLine() {
      _ref2 = NewLine.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    NewLine.prototype.toString = function() {
      return "\n";
    };

    return NewLine;

  })(WSToken);

  exports.WSManager = WSManager;

  WSBuffer = (function() {
    function WSBuffer(ops) {
      this.ops = ops;
      this.index = 0;
      this.bindex = 0;
      this.buf = "";
      this.push0_mode = false;
    }

    WSBuffer.prototype.clone = function() {
      var ret;
      ret = new WSBuffer(this.ops.concat([]));
      ret.index = this.index;
      ret.bindex = this.bindex;
      ret.buf = this.buf;
      ret.push0_mode = this.push0_mode;
      return ret;
    };

    WSBuffer.prototype.takeJust = function(type, last) {
      var char;
      if (!this.buf[this.bindex]) {
        if (!this.ops[this.index]) {
          if (this.push0_mode) {
            if (last) {
              return null;
            }
            if (type === "indent") {
              this.buf += "\t";
            } else {
              this.buf += " ";
            }
          } else {
            this.buf += "   ";
            this.push0_mode = true;
          }
        } else {
          this.buf += this.ops[this.index].getCode();
          this.index++;
        }
      }
      char = this.buf[this.bindex];
      if (char === " " || char === "\t") {
        /*
        process.stdout.write (switch char
            when " " then "[SP#{@bindex}]"
            when "\t" then "[TB#{@bindex}]"
        ).yellow
        */

        this.bindex++;
        return char;
      }
      return null;
    };

    WSBuffer.prototype.takeNewLine = function() {
      var char;
      if (!this.buf[this.bindex]) {
        if (!this.ops[this.index]) {
          if (this.push0_mode) {
            this.buf += "\n";
            this.push0_mode = false;
          } else {
            this.buf += "\n\n\n";
          }
        } else {
          this.buf += this.ops[this.index].getCode();
          this.index++;
        }
      }
      char = this.buf[this.bindex];
      if (char === "\n") {
        this.bindex++;
        return char;
      }
      return null;
    };

    WSBuffer.prototype.takeAll = function() {
      var op, result, _i, _len, _ref3;
      result = this.buf.slice(this.bindex);
      _ref3 = this.ops.slice(this.index);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        op = _ref3[_i];
        result += op.getCode();
      }
      this.bindex = this.buf.length;
      this.index = this.ops.length;
      return result;
    };

    WSBuffer.prototype.back = function(num) {
      if (num == null) {
        num = 1;
      }
      this.bindex -= num;
      if (this.bindex < 0) {
        this.bindex = 0;
      }
    };

    return WSBuffer;

  })();

  Blender = (function() {
    function Blender(tabWidth, indentWidth, tokens, ops) {
      this.tabWidth = tabWidth;
      this.indentWidth = indentWidth;
      this.tokens = tokens;
      this.ops = ops;
      this.buffer = new WSBuffer(this.ops);
      this.infinity_spaces = false;
    }

    Blender.prototype.takeLine = function() {
      var result, t, _i, _len, _ref3;
      result = [];
      _ref3 = this.tokens;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        t = _ref3[_i];
        result.push(t);
        if (t instanceof NewLine) {
          break;
        }
      }
      this.tokens = this.tokens.slice(result.length);
      return result;
    };

    Blender.prototype.blend = function() {
      var buf, ch, char, idx, len, line, newnow, now, result, str, t, tmp, to, _i, _j, _len, _len1;
      result = "";
      while (true) {
        line = this.takeLine();
        if (line.length === 0) {
          break;
        }
        while (true) {
          tmp = "";
          buf = this.buffer.clone();
          for (_i = 0, _len = line.length; _i < _len; _i++) {
            t = line[_i];
            if (t instanceof WSToken) {
              if (t instanceof Indent) {
                to = t.level * this.indentWidth;
                now = 0;
                char = null;
                while (char = buf.takeJust("indent")) {
                  switch (char) {
                    case " ":
                      tmp += " ";
                      now++;
                      break;
                    case "\t":
                      tmp += "\t";
                      newnow = (Math.floor(now / this.tabWidth) + 1) * this.tabWidth;
                      if (newnow <= to) {
                        now = newnow;
                      } else {
                        tmp = null;
                        break;
                      }
                      break;
                    default:
                      tmp = null;
                      break;
                  }
                  if (now === to) {
                    break;
                  }
                }
                if (tmp == null) {
                  break;
                }
                if (now < to) {
                  tmp = null;
                  break;
                }
              } else if (t instanceof Just) {
                char = buf.takeJust("just");
                if (char == null) {
                  tmp = null;
                  break;
                }
                tmp += char;
              } else if (t instanceof NewLine) {
                char = null;
                while (char = buf.takeJust("just", true)) {
                  tmp += char;
                }
                char = buf.takeNewLine();
                if (char == null) {
                  throw new Error("What!? Invalid char on buf");
                }
                tmp += char;
              }
            } else {
              str = t.toString();
              if (/\u0020|\t/.test(str)) {
                idx = 0;
                len = str.length;
                for (_j = 0, _len1 = str.length; _j < _len1; _j++) {
                  ch = str[_j];
                  if (ch === " " || ch === "\t") {
                    char = buf.takeJust("just");
                    if (ch === char) {
                      tmp += ch;
                      continue;
                    } else if (char != null) {
                      buf.back();
                    }
                  } else {
                    tmp += ch;
                    continue;
                  }
                  switch (ch) {
                    case " ":
                      ch = "\\u0020";
                      break;
                    case "\t":
                      ch = "\\t";
                  }
                  tmp += ch;
                }
              } else {
                tmp += str;
              }
            }
          }
          if (tmp == null) {
            tmp = "";
            char = null;
            buf = this.buffer.clone();
            while (char = buf.takeJust("just", true)) {
              tmp += char;
            }
            char = buf.takeNewLine();
            if (char == null) {
              throw new Error("What!?");
            }
            tmp += char;
            result += tmp;
            this.buffer = buf;
            continue;
          }
          this.buffer = buf;
          result += tmp;
          break;
        }
      }
      str = null;
      str = this.buffer.takeAll();
      if (str) {
        result += str;
      }
      return result;
    };

    return Blender;

  })();

  exports.Blender = Blender;

}).call(this);
