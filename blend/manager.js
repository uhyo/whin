// Generated by CoffeeScript 1.6.3
(function() {
  var Blender, Indent, Just, NewLine, WSBuffer, WSManager, WSToken, operations, parser, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  parser = require('../js/parser');

  operations = require('../ws/operations');

  WSManager = (function(_super) {
    __extends(WSManager, _super);

    function WSManager() {
      _ref = WSManager.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    WSManager.prototype.just = function() {
      return new Just;
    };

    WSManager.prototype.indent = function(tokenlist) {
      var flg, ret, t, _i, _len;
      ret = new tokenlist.constructor;
      flg = true;
      for (_i = 0, _len = tokenlist.length; _i < _len; _i++) {
        t = tokenlist[_i];
        if (flg) {
          flg = false;
          if (t instanceof Indent) {
            ret.push(new Indent(t.level + 1));
          } else {
            ret.push(new Indent(1));
            ret.push(t);
          }
        } else {
          ret.push(t);
        }
        if (t instanceof NewLine) {
          flg = true;
        }
      }
      return ret;
    };

    WSManager.prototype.newline = function() {
      return new NewLine;
    };

    WSManager.prototype.chomp = function(tokenlist) {
      var t, _i;
      for (_i = tokenlist.length - 1; _i >= 0; _i += -1) {
        t = tokenlist[_i];
        if (t instanceof NewLine) {
          tokenlist.pop();
        } else {
          break;
        }
      }
      return tokenlist;
    };

    return WSManager;

  })(parser.TokenizeManager);

  WSToken = (function() {
    function WSToken() {}

    WSToken.prototype.likeIdentifier = function() {
      return false;
    };

    return WSToken;

  })();

  Just = (function(_super) {
    __extends(Just, _super);

    function Just() {
      _ref1 = Just.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Just.prototype.toString = function() {
      return "[Just]";
    };

    return Just;

  })(WSToken);

  Indent = (function(_super) {
    __extends(Indent, _super);

    function Indent(level) {
      this.level = level;
    }

    Indent.prototype.toString = function() {
      return "[Indent" + this.level + "]";
    };

    return Indent;

  })(WSToken);

  NewLine = (function(_super) {
    __extends(NewLine, _super);

    function NewLine() {
      _ref2 = NewLine.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    NewLine.prototype.toString = function() {
      return "\n";
    };

    return NewLine;

  })(WSToken);

  exports.WSManager = WSManager;

  WSBuffer = (function() {
    function WSBuffer(ops, lv) {
      this.ops = ops;
      this.lv = lv;
      this.index = -1;
      this.bindex = 0;
      this.buf = "";
      this.stream_mode = null;
      this.killed = false;
    }

    WSBuffer.prototype.clone = function() {
      var ret;
      ret = new WSBuffer(this.ops.concat([]), this.lv);
      ret.index = this.index;
      ret.bindex = this.bindex;
      ret.buf = this.buf;
      ret.stream_mode = this.stream_mode;
      ret.killed = this.killed;
      return ret;
    };

    WSBuffer.prototype.takeJust = function(type, last) {
      var char;
      if (this.killed) {
        throw new Error("dead");
      }
      if (!this.buf[this.bindex]) {
        if (this.stream_mode === "push0-add") {
          if (last) {
            return null;
          }
          this.buf += " ";
        } else if (this.stream_mode === "push-free") {
          if (last) {
            return null;
          }
          if (type === "indent") {
            this.buf += "\t";
          } else {
            this.buf += " ";
          }
        } else if (!this.ops[this.index + 1]) {
          this.buf = "   ";
          this.bindex = 0;
          this.stream_mode = "push-free";
        } else {
          this.index++;
          this.buf = this.ops[this.index].getCode();
          this.bindex = 0;
        }
      }
      char = this.buf[this.bindex];
      if (char === " " || char === "\t") {
        /*
        process.stdout.write (switch char
            when " " then "[SP#{@bindex}]"
            when "\t" then "[TB#{@bindex}]"
        ).yellow
        */

        this.bindex++;
        return char;
      }
      return null;
    };

    WSBuffer.prototype.takeNewLine = function() {
      var char;
      if (this.killed) {
        throw new Error("dead");
      }
      if (!this.buf[this.bindex]) {
        if (this.stream_mode === "push-free") {
          this.buf += "\n";
          this.stream_mode = null;
        } else if (this.stream_mode === "push0-add") {
          this.buf += "\n";
          this.stream_mode = null;
          this.ops.splice(this.index + 1, 0, new operations.arithmetic.Add);
        } else if (!this.ops[this.index + 1]) {
          this.buf = "\n\n\n";
          this.bindex = 0;
        } else {
          this.index++;
          this.buf = this.ops[this.index].getCode();
          this.bindex = 0;
        }
      }
      char = this.buf[this.bindex];
      if (char === "\n") {
        this.bindex++;
        return char;
      }
      return null;
    };

    WSBuffer.prototype.takeAll = function() {
      var op, result, _i, _len, _ref3;
      if (this.killed) {
        throw new Error("dead");
      }
      result = this.buf.slice(this.bindex);
      _ref3 = this.ops.slice(this.index + 1);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        op = _ref3[_i];
        result += op.getCode();
      }
      this.bindex = this.buf.length;
      this.index = this.ops.length - 1;
      return result;
    };

    WSBuffer.prototype.back = function(num) {
      if (num == null) {
        num = 1;
      }
      while (num >= 0) {
        if (this.bindex >= num) {
          this.bindex -= num;
          break;
        }
        num -= this.bindex;
        this.index--;
        if (this.index < 0) {
          throw new Error("Cannot back");
        }
        this.buf = this.ops[this.index];
        this.bindex = this.buf.length;
      }
    };

    WSBuffer.prototype.takeIndent = function(width, tabWidth, force) {
      var char, newtaken, result, taken;
      if (this.killed) {
        throw new Error("dead");
      }
      result = "";
      taken = 0;
      char = null;
      while (true) {
        char = this.takeJust("indent");
        switch (char) {
          case " ":
            result += " ";
            taken++;
            break;
          case "\t":
            result += "\t";
            newtaken = (Math.floor(taken / tabWidth) + 1) * tabWidth;
            if (newtaken <= width) {
              taken = newtaken;
            } else {
              if (!(force && this.lv >= 2)) {
                result = null;
                break;
              } else {
                if (this.buf.slice(0, this.bindex).indexOf("\n") >= 0) {
                  result = null;
                  break;
                }
                result = result.slice(0, result.length - this.bindex);
                taken = this.calcIndent(result, tabWidth);
                this.buf = "   ";
                this.bindex = 0;
                this.index--;
                this.stream_mode = "push0-add";
              }
            }
            break;
          default:
            if (!(force && this.lv >= 2)) {
              result = null;
              break;
            } else {
              if (!this.buf || this.buf.slice(0, this.bindex).indexOf("\n") >= 0) {
                result = null;
                break;
              }
              result = result.slice(0, result.length - this.bindex);
              taken = this.calcIndent(result, tabWidth);
              this.buf = "   ";
              this.bindex = 0;
              this.index--;
              this.stream_mode = "push0-add";
            }
        }
        if (result == null) {
          result = null;
          break;
        }
        if (taken === width) {
          break;
        }
      }
      if (result == null) {
        this.killed = true;
      }
      return result;
    };

    WSBuffer.prototype.calcIndent = function(str, tabWidth) {
      var char, result, _i, _len;
      result = 0;
      for (_i = 0, _len = str.length; _i < _len; _i++) {
        char = str[_i];
        switch (char) {
          case " ":
            result++;
            break;
          case "\t":
            result = (Math.floor(result / tabWidth) + 1) * tabWidth;
        }
      }
      return result;
    };

    return WSBuffer;

  })();

  Blender = (function() {
    function Blender(tabWidth, indentWidth, tokens, ops, lv) {
      this.tabWidth = tabWidth;
      this.indentWidth = indentWidth;
      this.tokens = tokens;
      this.lv = lv != null ? lv : 1;
      this.ops = ops.concat([]);
      if (this.lv >= 2) {
        this.ops.unshift(new operations.stack.Push(0));
      }
      this.buffer = new WSBuffer(this.ops, this.lv);
      this.infinity_spaces = false;
    }

    Blender.prototype.takeLine = function() {
      var result, t, _i, _len, _ref3;
      result = [];
      _ref3 = this.tokens;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        t = _ref3[_i];
        result.push(t);
        if (t instanceof NewLine) {
          break;
        }
      }
      this.tokens = this.tokens.slice(result.length);
      return result;
    };

    Blender.prototype.blend = function() {
      var buf, ch, char, idx, ifailureCount, indentstr, len, line, now, result, str, t, tmp, to, _i, _j, _len, _len1;
      result = "";
      while (true) {
        line = this.takeLine();
        if (line.length === 0) {
          break;
        }
        ifailureCount = 0;
        while (true) {
          tmp = "";
          buf = this.buffer.clone();
          for (_i = 0, _len = line.length; _i < _len; _i++) {
            t = line[_i];
            if (t instanceof WSToken) {
              if (t instanceof Indent) {
                to = t.level * this.indentWidth;
                now = 0;
                char = null;
                /*
                while char=buf.takeJust "indent"
                    switch char
                        when " "
                            tmp+=" "
                            now++
                        when "\t"
                            tmp+="\t"
                            newnow=(Math.floor(now/@tabWidth)+1)*@tabWidth
                            if newnow<=to
                                now=newnow
                            else
                                # この行は無理だわ…
                                tmp=null
                                break
                        else
                            # やっぱ無理だわ…
                            tmp=null
                            break
                    if now==to
                        # インデント成功
                        #console.log "ok!".yellow,[].map.call(tmp,(x)->x.charCodeAt(0)).join()
                        break
                */

                indentstr = buf.takeIndent(t.level * this.indentWidth, this.tabWidth, ifailureCount >= 1);
                if (indentstr == null) {
                  tmp = null;
                  ifailureCount++;
                  break;
                }
                tmp += indentstr;
              } else if (t instanceof Just) {
                char = buf.takeJust("just");
                if (char == null) {
                  tmp = null;
                  break;
                }
                tmp += char;
              } else if (t instanceof NewLine) {
                char = null;
                while (char = buf.takeJust("just", true)) {
                  tmp += char;
                }
                char = buf.takeNewLine();
                if (char == null) {
                  throw new Error("What!? Invalid char on buf");
                }
                tmp += char;
              }
            } else {
              str = t.toString();
              if (/\u0020|\t/.test(str)) {
                idx = 0;
                len = str.length;
                for (_j = 0, _len1 = str.length; _j < _len1; _j++) {
                  ch = str[_j];
                  if (ch === " " || ch === "\t") {
                    char = buf.takeJust("just");
                    if (ch === char) {
                      tmp += ch;
                      continue;
                    } else if (char != null) {
                      buf.back();
                    }
                  } else {
                    tmp += ch;
                    continue;
                  }
                  switch (ch) {
                    case " ":
                      ch = "\\u0020";
                      break;
                    case "\t":
                      ch = "\\t";
                  }
                  tmp += ch;
                }
              } else {
                tmp += str;
              }
            }
          }
          if (tmp == null) {
            tmp = "";
            char = null;
            buf = this.buffer.clone();
            while (char = buf.takeJust("just", true)) {
              tmp += char;
            }
            char = buf.takeNewLine();
            if (char == null) {
              throw new Error("What!?");
            }
            tmp += char;
            result += tmp;
            this.buffer = buf;
            continue;
          }
          this.buffer = buf;
          result += tmp;
          break;
        }
      }
      str = null;
      str = this.buffer.takeAll();
      if (str) {
        result += str;
      }
      return result;
    };

    return Blender;

  })();

  exports.Blender = Blender;

}).call(this);
